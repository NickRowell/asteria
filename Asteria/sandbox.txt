# This file is intended to contains scraps of code that may be of use in the main project,
# but that aren't currently being used and I don't want to leave them around to clutter it up.

// Initialise the camera

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++//
//                                                       //
//    Determine available pixel formats and pick one     //
//                                                       //
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++//

// Already configured

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++//
//                                                       //
//   Determine the available image sizes for the chosen  //
//   pixel format and pick one                           //
//                                                       //
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++//

// Already configured

//    struct v4l2_frmsizeenum framesize;
//    memset(&framesize, 0, sizeof(framesize));
//    framesize.pixel_format = state->selectedFormat;
//    framesize.index = 0;

//    while( ioctl(*(this->state->fd), VIDIOC_ENUM_FRAMESIZES, &framesize ) == 0 )
//    {
//        // TODO: what are the implications of the different types?
//        switch(framesize.type) {
//        case V4L2_FRMSIZE_TYPE_DISCRETE: {

//            unsigned int width  = framesize.discrete.width;
//            unsigned int height = framesize.discrete.height;
//            qInfo() << "V4L2_FRMSIZE_TYPE_DISCRETE: Width x Height = " << width << " x " << height;
//            break;
//        }
//        case V4L2_FRMSIZE_TYPE_STEPWISE: {
//            qInfo() << "V4L2_FRMSIZE_TYPE_STEPWISE not supported!";
//            break;
//        }

//        }

//        framesize.index++;
//    }





// Saving images to file:

// Write the image data out to a JPEG file
//        int imgFileHandle;
//        char filename [100];

//        switch(format->fmt.pix.pixelformat) {
//        case V4L2_PIX_FMT_GREY:
//            sprintf(filename, "/home/nick/Temp/myimage_%lu_%u.pgm", i, j);
//            break;
//        case V4L2_PIX_FMT_MJPEG:
//            sprintf(filename, "/home/nick/Temp/myimage_%lu_%u.jpeg", i, j);
//            break;
//        }


//        if((imgFileHandle = open(filename, O_WRONLY | O_CREAT, 0660)) < 0){
//            perror("open");
//            exit(1);
//        }

// PGM (grey image)
//        std::ofstream out(filename);
//        // Raw PGMs:
//        out << "P5\n" << state->width << " " << state->height << " 255\n";
//        for(unsigned int k=0; k<state->height; k++) {
//            for(unsigned int l=0; l<state->width; l++) {
//                unsigned int offset = k*state->width + l;
//                // Pointer to the pixel data
//                char * pPix = (char *)(buffer_start[j]+offset);
//                // Cast to a char
//                char pix = *pPix;
//                out << pix;
//            }
//        }
//        out.close();


// JPEG (write the raw buffer data to file rather than the converted greyscale image)
//            write(imgFileHandle, state->buffer_start[j], bufferinfo->length);

//        ::close(imgFileHandle);
